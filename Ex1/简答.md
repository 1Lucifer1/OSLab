##### 请简述 80x86 系列的发展历史

- 1978年6月，intel推出第一款16位微处理器8086，采用20位地址线  
- 1982年发布80286，主频提高至12MHz
- 1985年发布80386，处理器变为32位，地址线扩展至32位
- 1989年发布80486，1993年发布80586并命名为奔腾

##### 说明小端和大端的区别，并说明 80x86 系列采用了哪种方式?

- 小端：较高的有效字节存放在较高的的存储器地址，较低的有效字节存放在较低的存储器地址。
- 大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。
- 采用小端

##### 8086 有哪五类寄存器，请分别举例说明其作用?

- 数据寄存器

- 指针寄存器

- 变址寄存器

- 控制寄存器

- 段寄存器

##### 什么是寻址?立即寻址和直接寻址的区别是什么?

- 找到操作数的地址从而找到操作数

- 立即寻址：直接给出操作数（没有寻址）

- 直接寻址：直接给出操作数的有效地址找到操作数

##### 请举例说明寄存器间接寻址、寄存器相对寻址、基址加变址寻址、相对基址加变址寻址四 种方式的区别

- 寄存器间接寻址 mov ax,[bx]，有效地址存在bx中，根据地址找到操作数，取出后存在ax中
- 寄存器相对寻址，mov ax,[si+3]，源地址存在si中，再加上偏移量获得操作数有效地址，从而获得操作数
- 基址加变址寻址 mov ax,[bx+di]，把一个基址寄存器(BX、BP)的内容，加上变址寄存器(SI、DI)的内容，并以一个段寄存器作为地址基准
- 相对基址加变址寻址 mov ax, [bx+di+3]，操作数在存储器中，其有效地址是一个基址寄存器(BX、BP)的值、一个变址寄存器(SI、DI)的值和指令中的8位/16位偏移量之和

##### 请分别简述 MOV 指令和 LEA 指令的用法和作用?

- mov ----为数据传送指令，可以在寄存器（立即数）、内存之间双向传递数据。
- lea ----取内存单元的有效地址指令，只用于传送地址。

- 前者的使用范围更广，前者可以实现后者的功能。如：
  lea dx, array
  可用：
  mov ax,offset array
  mov dx,ax
  替代

##### 请说出主程序与子程序之间至少三种参数传递方式

- 寄存器法

  寄存器法就是将入口参数和出口参数存放在约定的寄存器中。

  优点：数据传递书读快、编程较方便、节省内存单元。

  缺点：当传递参数过多时候，由于寄存器个数有限，及寄存器的频繁使用，将导致寄存器不足。

  适用：参数较少的子程序

- 约定单元法：

  约定单元法顾名思义是吧入口参数和出口参数都放在事先约定好的单元中

  优点：不占用寄存器、参数个数任意、每个子程序要处理的数据和送出的结构都有独立的存储单元

  缺点：但用一定数量的存储单元，增加编程中对变量定义的难度

- 堆栈法

  堆栈法是利用堆栈来传递参数的。

  优点：参数不占用寄存器，和存储单元。参数存放在公共堆栈区，处理完后客恢复。参数个数一般不限

  缺点：由于参数和子程序混杂在一起，存取参数时候必须小心计算它在堆栈中的位置。要注意断点的保存和恢复。

- 地址表法

  这种方法是把参数组成的一张参数表放在某个存储区中，然后只要主程序和子程序约定好这个存储区的首地址和存放的内容，在主程序中将参数传递给地址表，在子程序中根据地址表给定的参数就可以完成操作。

##### 如何处理输入和输出，代码中哪里体现出来?

- 输入

  mov ebx,0；文件描述符，STDIN

  mov eax,3；保存系统调用号，4是System_read的系统调用号

  mov ecx,*input*；为在 .bss 部分中创建的变量的地址(变量名)

  mov edx,64；缓冲区大小

  int 80h；进行系统调用

- 输出

  mov ecx,*msg* ；要输出的信息首地址

  mov edx,*msglen*；要输出的信息的长度

  mov ebx,1；文件描述符，STDOUT

  mov eax,4；eax保存系统调用号，4是System_write的系统调用号

  int 80h；进行系统调用

##### 有哪些段寄存器

- CS 代码段
- DS 数据段
- ES 附加段
- SS 堆栈段

##### 通过什么寄存器保存前一次的运算结果，在代码中哪里体现出来。

如果是两个寄存器的话一般就是前一个寄存器，比如 add  ax,bx 结果存储在ax中

除法比较特殊，因为要保存商和余数

##### 解释 boot.asm 文件中，org 0700h 的作用

- 告诉汇编器，当前这段代码会放在07c00h处。所以，如果之后遇到需要绝对寻址地指令，那么绝对地址就是07c00h加上相对地址。
  绝对地址：内存的实际位置（先不考虑内存分页一类逻辑地址）
  相对地址：当前指令相对第一行代码的位置。
  在第一行加上org 07c00h只是让编译器从相对地址07c00h处开始编译第一条指令，相对地址被编译加载后就正好和绝对地址吻合

##### boot.bin 应该放在软盘的哪一个扇区?为什么?

- 第一扇区

- 原因：

  开机，从ROM运行BIOS程序，BIOS是厂家写好的。

  BIOS程序检查软盘0面0磁道1扇区，如果扇区以0xaa55结束，则认定为引导扇区，将其512字节的数据加载到内存的07c00处，然后设置PC，跳到内存07c00处开始执行代码。

  以上的0xaa55以及07c00都是一种约定，BIOS程序就是这样做的，所以我们就需要把我们的os放在软盘的第一个扇区，填充，并在最末尾写入0xaa55

##### loader 的作用有哪些?

- 跳入保护模式
  - 最开始的x86处理器16位，寄存器用ax, bx等表示，称为实模式。后来扩充成32位，eax，ebx等，为了向前兼容，提出了保护模式
  - 必须从实模式跳转到保护模式，才能访问1M以上的内存。

- 启动内存分页
- 从kernel.bin中读取内核，并放入内存，然后跳转到内核所在的开始地址，运行内核
  - 跟boot类似，使用汇编直接在软盘下搜索kernel.bin
  -  但是，不能把整个kernel.bin放在内存，而是要以ELF文件的格式读取并提取代码。

##### 解释 NASM 语言中 [ ] 的作用

- 取出主存地址内存储的操作数

##### 解释语句 times 510-(\$-\$\$) db 0，为什么是 510? \$ 和 \$\$ 分别表示什么?

- times 510-(\$-\$\$) db 0 表示填充 510-(\$-\$\$) 这么多个字节的0
  这里面的\$表示当前指令的地址，\$\$表示程序的起始地址(也就是最开始的7c00)，所以\$-\$\$就等于本条指令之前的所有字节数。510-(\$-\$\$)的效果就是，填充了这些0之后，从程序开始到最后一个0，一共是510个字节。再加上最后的dw两个字节(0xaa55是结束标志)，整段程序的大小就是512个字节，刚好占满一个扇区

##### 解释配置文件 bochsrc 文件中各参数的含义

- megs:32 用于设置模拟系统的内存，这里使用的是32MB

- display_library: sdl bochs使用的GUI库，在Ubuntu下面是sdl

- floppya: 1_44=a.img, status=inserted 

  floppya和floppyb分别表示第一个软驱和第二个软驱，如果需要从一个软盘上来引导系统则floppya就需要指向一个可引导的磁盘，软盘为a.img

- boot: floppy 虚拟机启动方式，从软盘启动。用来定义模拟机器中踊跃引导启动的驱动器，可以为软盘硬盘或CDROM